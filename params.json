{"name":"DepSky","tagline":"\"Dependable and Secure Storage in a Cloud-of-Clouds\"","body":"## Introduction\r\nDepSky is a system that improves the availability, confidentiality and integrity of stored data in the cloud. It reaches this goal by encrypting, enconding and replicating all the data on a set of differents clouds, forming a cloud-of-clouds. For the current implementation of the system and for the text below we consider a cloud-of-clouds formed by four clouds.\r\n\r\nMore specifically DepSky address four important limitations:\r\n\r\n* _Loss of availability_ - DepSky addresses this limitation because it replicates all the data in a set of clouds, and even if some of them presents some problems, all the data will be available if a subset of them are reachable.\r\n\r\n* _Loss an corruption of data_ - DepSky deals with this problem using Byzantine fault-tolerance replication to store data in a cloud-of-clouds, being possible get the data correctly even if some of the clouds corrupt or lose data.\r\n\r\n* _Loss of privacy_ - DepSky employs a secret sharing scheme and erasure codes to ensure that all data that will be stored in a cloud-of-clouds is in ciphertext.\r\n\r\n* _Vendor lock-in_ - DepSky addresses this limitation because unlike use a single cloud provider, use a set of them.\r\n\r\n## Protocols\r\n\r\nBelow is a brief explanation of the DepSky protocols to store data in a cloud-of-clouds. All of them replicate the data for all clouds used but only is ensured that the data is properly stored in three (due to the Byzantines quoruns).\r\n\r\n#### DepSky-A\r\n\r\nThis protocol replicates all the data in clear text in each cloud.\r\n\r\n#### DepSky-CA\r\n\r\nThis protocol uses secret sharing and erasure code techniques to replicate the data in a cloud-of-clouds. The image below show how this is donne. First is generated an encryption key, and after that the original data block is encrypted. Then the encrypted data block is erasure coded and are computed key shares of the encryption key. In this case we get four erasure coded blocks and four key shares because we use four clouds. Lastly, is stored in each cloud a different coded block together with a different key share.\r\n\r\n`<FIGURE>`\r\n\r\n#### DepSky-only-JSS\r\n\r\nThis protocol only use secret sharing. Basically, is generated an encryption key and the data is encrypted. Then is generated four key shares of the key. Finally are spread by each cloud the data encrypted together with a different key share.\r\n\r\n#### DepSky-only-JEC\r\n\r\nOn the other hand, this protocol only use erasure codes to replicate the data. The data is erasure coded in four different blocks and then each of them is stored in a different provider.\r\n\r\nThis protocol may be useful to those who your application already encrypt the data.\r\n\r\n## Costs\r\n\r\nAs would be expected, a DepSky client would be required to pay four (using a cloud-of-clouds of four cloud providers) times more than he would pay if uses a single cloud. That not happens (if using DepSky-CA protocol) due to the erasure codes techniques. The erasure codes technique used (see [JEC](wiki-jec)) allow us to store in each of the four cloud providers only half of the orginal block data size. So, using DepSky, the client only will pay twice more than using a single cloud.\r\n\r\nFor more information see the DepSky paper. You can find it here [EuroSys'11 paper](http://www.di.fc.ul.pt/~bessani/publications/eurosys11-depsky.pdf).\r\n\r\n***\r\n\r\n## Getting Started with DepSky\r\n\r\nThis section explains you how to create the providers accounts to form a cloud-of-clouds environment.\r\nIf you want to test DepSky without create the accounts, you can use local storage instead.\r\nPlease read the next section called [Testing DepSky](#testing-depsky).\r\n\r\nFirst of all, you need to download the latest stable version available and extract it.\r\nMake sure you have java 1.7 or later installed.\r\n\r\nDone this, you need to fill up the _accounts.properties_ file (you can find it inside the config folder).\r\nTo fill up this file you need first create accounts in the cloud providers we support.\r\nTo do that follow the links below:\r\n\r\n* [_Amazon S3_](http://aws.amazon.com/s3/)\r\n\r\n* [_Google Storage_](https://developers.google.com/storage/)\r\n\r\n* [_RackSpace Files_](http://www.rackspace.co.uk/)\r\n\r\n* [_Windows Azure Strorage_](https://www.windowsazure.com/en-us/)\r\n\r\nAfter create the accounts you have access to yours API keys and so, you can fill up the accounts.properties file. To help you to find your keys, follow the steps below.\r\n\r\n* To find Amazon s3 keys go to the AWS Management Console, click in S3 service, now, in the upper right corner click in your account name and go to the Security Credentials. After that, in the Access Keys separator you can generate your access and secret keys.\r\n\r\n* To find Google Storage keys go to the Google API Console, and then go to the Google Cloud Storage separator. Now choose Interoperable Access and there you can find your keys. Don't forget first enable Google Cloud Storage in the services separator.\r\n\r\n* To find RackSpace? keys, go to the Control Panel. In the upper right corner you can find how to get your secret key. The access key is just your login username.\r\n\r\n* To find Windows Azure keys go to the windows azure portal. First you need to create a new storage project. After select this new project, at the bottom of the page, you can find the key management. In this case your access key is your storage project name and you secret key is the primary key in the key management.\r\n\r\nIf you only want to use Amazon S3 as your cloud storage provider, you can only create one account at Amazon S3 and use the example file provided (_config/accounts_amazon.properties_). To do that, copy the content of the 'accounts_amazon.properties' file to the one mentioned before (_config/accounts.properties_). In this case will be used four different Amazon S3 locations to store the data (US_Standard, EU_Ireland, US_West and AP_Tokyo).\r\n\r\nNow all the setup is finished and DepSky is ready to be used.\r\n\r\n## Testing DepSky\r\n\r\nTo test DepSky we provide a simple main that can be found in _src.depskys.core.LocalDepSkySClient_. To run this main use the _DepSky_Run.sh_ scritp at the root of the project providing 3 arguments:\r\n\r\n* The first one is the client id (for now use ids below 6 because we only have keys generated for ids until the 6).\r\n\r\n* The second argument indicates what protocol will be used to replicate the data. There are 4 possibilities:\r\n  \r\n  * 0 means that will be used DepSky-A (there is no erasure codes neither secret sharing).\r\n  \r\n  * 1 to use DepSky-CA (use erasure codes and secret sharing).\r\n  \r\n  * 2 for use only erasure codes.\r\n  \r\n  * 3 to use only secret sharing.\r\n\r\n* The third argument indicated the storage location.\r\n  \r\n  * 0 if you want to use cloud storage to replicate the data.\r\n  \r\n  * 1 if you want to store all the data locally (testing purposes). If you want to use the local storage you need first run the server that can be found in _src.depskys.clouds.drivers.localStorageService.ServerThread_. To run this server you can use the _Run_LocalStorage.sh_ script at the root fo the project. This server will receive all requests at ip _127.0.0.1_ and port _5555_.\r\n\r\nLet us give you an example.\r\nIf we run DepSky with the command below, we gonna start a session with the client id 0, all the data will be replicated using erasure codes and secret sharing and will be stored on the cloud providers.\r\n\r\n`$ ./DepSky_Run 0 1 0`\r\n\r\nThis main allow you to read, write and delete. You have five commands available:\r\n\r\n* _pick_du 'name'_ - will change the container that you are using to read and write.\r\n\r\n* _write 'data'_ - will write a new version with the content 'data' over the container selected.\r\n\r\n* _read_ - will read the last version written to the container selected\r\n\r\n* _delete_ - will delete all the data (data and metadata files) associated with the container selected.\r\n\r\n* _read_m 'num'_ - will read old versions over the container selected. If 'num' = 0, will read the last version written, if 'num' = 1, will read the penultimate version written, etc. Note that only is possible read old versions written in this session because this main maintain all the information in memory. To read all the old versions this main must be changed.\r\n\r\nThis main is not enough to take advantage of all the functionalities provided by DepSky. To learn more about all you can do with DepSky read the nexte section.\r\n\r\n## Using DepSky as a Library\r\n\r\nTo start, you need to create a _src.depskys.core.LocalDepSkySClient_ object. As you can see below, the constructor receive the client id and a _boolean_. If the _boolean_ value is set to _false_, will be used the **local storage**, otherwise will be used the **cloud storage**.\r\n\r\n```java\r\npublic LocalDepSkySClient(int clientId, boolean useModel) throws StorageCloudException {\r\n\r\n        this.clientId = clientId;\r\n        DepSkySKeyLoader keyLoader = new DepSkySKeyLoader(null);\r\n        if(!useModel){\r\n                this.cloud1 = new LocalDiskDriver(\"cloud1\");\r\n                this.cloud2 = new LocalDiskDriver(\"cloud2\");\r\n                this.cloud3 = new LocalDiskDriver(\"cloud3\");\r\n                this.cloud4 = new LocalDiskDriver(\"cloud4\");\r\n                this.drivers = new IDepSkySDriver[]{cloud1, cloud2, cloud3, cloud4};\r\n        }else{  \r\n                List<String[][]> credentials = null;\r\n                try {\r\n                        credentials = readCredentials();\r\n                } catch (FileNotFoundException e) {     \r\n                        System.out.println(\"accounts.properties file dosen't exist!\");\r\n                        e.printStackTrace();\r\n                } catch (ParseException e) {\r\n                        System.out.println(\"accounts.properties misconfigured!\");               \r\n                        e.printStackTrace();\r\n                }\r\n                this.drivers = new IDepSkySDriver[4];\r\n                String type = null, driverId = null, accessKey = null, secretKey = null;\r\n                for(int i = 0 ; i < credentials.size(); i++){\r\n                        for(String[] pair : credentials.get(i)){\r\n                                if(pair[0].equalsIgnoreCase(\"driver.type\")){\r\n                                        type = pair[1];\r\n                                }else if(pair[0].equalsIgnoreCase(\"driver.id\")){\r\n                                        driverId = pair[1];\r\n                                }else if(pair[0].equalsIgnoreCase(\"accessKey\")){\r\n                                        accessKey = pair[1];\r\n                                }else if(pair[0].equalsIgnoreCase(\"secretKey\")){\r\n                                        secretKey = pair[1];\r\n                                }\r\n                        }\r\n                        drivers[i] = DriversFactory.getDriver(type, driverId, accessKey, secretKey);\r\n                }\r\n        }       \r\n        this.manager = new DepSkySManager(drivers, this, keyLoader);\r\n        this.replies = new HashMap<Integer, CloudRepliesControlSet>();\r\n        this.N = drivers.length;\r\n        this.F = 1;\r\n        this.encoder = new ReedSolEncoder(2, 2, 8);\r\n        this.decoder = new ReedSolDecoder(2, 2, 8);\r\n\r\n        if(!startDrivers()){\r\n                System.out.println(\"Connection Error!\");\r\n        }\r\n  }\r\n```\r\n\r\nThe second step is create too many _src.depskys.core.DepSkySDataUnit_ objects as you want.\r\nEach object of this type represents our storage model.\r\nConcretely, a _src.depskys.core.DepSkySDataUnit_ refers to an object that have associated one metadata file and all the versions written to it.\r\nThe example bellow illustrate it.\r\n\r\n```\r\n  exampleFilemetadata\r\n  exampleFilevalue1004\r\n  exampleFilevalue2004\r\n  exampleFilevalue3004\r\n  ...\r\n```\r\n\r\n\r\nEach _DepSkySDataUnit_ object contains information about the protocol used to replicate the data, the metadata information, the written versions, etc. Furthermore, each one of these objects (by that we mean all the files associated with it) can be stored in a different bucket. There are two ways to create a _DepSkySDataUnit_ object. The first example below (1) will write to a container named regId (which will contain regIdmetadata and regIdvalue files) inside a default bucket of DepSky. Using the second example a user is able to specify the bucket where the data will be stored.\r\n\r\n```java\r\n  (1)\r\n  public DepSkySDataUnit(String regId) {\r\n  ...\r\n  \r\n  (2)\r\n  public DepSkySDataUnit(String regId, String bucketName) {\r\n  ...\r\n```\r\n\r\nAfter creating a _DepSkySDataUnitobject_, you need to specify what protocol will be used to replicate the data that will be written in this container. By default, each _DepSkySDataUnit_ object will use DepSky-A (data is replicated in clear_text). To use one of the others three protocols follow the code below.\r\n\r\n```java\r\n  DepSkySDataUnit dataUnit = new DepSkySDataUnit(\"container\");\r\n  dataUnit.setUsingPVSS(true); //to use DepSky-CA\r\n  dataUnit.setUsingErsCodes(true); //to use only erasure codes\r\n  dataUnit.setUsingSecSharing(true); //to use only secret sharing\r\n```\r\n\r\nWhen you want to perform operations in the _LocalDepSkySClient_ object (_read_, _write_, etc) you have to use a _DepSkySDataUnit_ object.\r\n\r\n#### Write\r\n\r\nWhen you want to use the write operation, you have to pass the _DepSkySDataUnit_ object for which you want to write and the data to be written. As we can see below, this operation return a _byte[]_. This _byte[]_ is a SHA-1 hash of the written data. This hash must be saved by the client if he want to use the read matching operation (see bellow).\r\n\r\n```java\r\n  public synchronized byte[] write(DepSkySDataUnit reg, byte[] value) throws Exception {\r\n  ...\r\n```\r\n\r\n#### Read\r\n\r\nTo use this operation, you only have as argument the _DepSkySDataUnit_ object. This operation will read the last version written to this _DepSkySDataUnit_.\r\n\r\n```java\r\n  public synchronized byte[] read(DepSkySDataUnit reg) throws Exception {\r\n  ...\r\n```\r\n\r\n#### Read Matching\r\n\r\nThis operation have the function of read a old version of a given _DepSkySDataUnit_. To do that you have to pass a _byte[]_ containing the hash of the version you want to read. This hash is the one returned by the write operation.\r\n\r\n```java\r\n  public synchronized byte[] readMatching(DepSkySDataUnit reg, byte[] hashMatching) throws Exception{\r\n  ...\r\n```\r\n\r\n#### Delete\r\n\r\nThe delete operation will delete all the files associated with the given _DepSkySDataUnit_, that includes all the versions written and the metadata file.\r\n\r\n```java\r\n  public synchronized void deleteContainer(DepSkySDataUnit reg) throws Exception{\r\n  ...\r\n```\r\n\r\n#### SetAcl\r\n\r\nThe setacl operation will change the permissions of a specified _DepSkySDataUnit_. Specifically, it will change the permissions of the bucket where the objects are stored, as well as the permissions of the objects within it. For do that we have to share the bucket in the four used clouds (once the data is replicated among them). The protocols to share a bucket in the used clouds can be found in this [paper](http://www.navigators.di.fc.ul.pt/w2/img_auth.php/d/de/Oliveira2014DIHC.pdf).\r\n\r\n```java\r\n  public synchronized LinkedList<Pair<String, String[]>> setAcl(DepSkySDataUnit reg, String permission,                                      \r\n     LinkedList<Pair<String, String[]>> cannonicalIds) throws Exception {\r\n  ...\r\n```\r\n\r\nThe operation receives 3 arguments. The first corresponds to the _DepSkySDataUnit_ that will be shared. The second specifies the permission that other users will have to access the specified DepSkySDataUnit. It can be \"r\" for read, \"w\" for write, and \"rw\" for read and write. The last field has information about the user who will have access to the shared resource. This last field must be constructed following the example below where each line represent an entry in the LinkedList (which is a Pair<String, String>).\r\n\r\n```\r\n -> <\"AMAZON-S3\", [canonicalId]>\r\n -> <\"GOOGLE-STORAGE\", [email]>\r\n -> <\"RACKSPACE\", [name, email]>\r\n -> <\"WINDOWS-AZURE\", []>\r\n```\r\n\r\nFor Amazon S3, the grantee user can find the canonicalId in the same page of the access credential (see the beginning of this page). For the other clouds, the information is quite intuitive. For Google Storage is only need the email of the grantee (must be a gmail account). For RackSpace the name and the grantee. Finally, for Windows Azure nothing is needed (see this [paper](http://www.navigators.di.fc.ul.pt/w2/img_auth.php/d/de/Oliveira2014DIHC.pdf)).\r\n\r\nThis operation returns a _LinkedList<Pair<String, String[]>>_ with the same organization of the one given as argument.\r\nThis list must be given to the grantee user, as well as the name of the _DepSkySDataUnit_ in order he can access the shared resource. But first the user who is sharing must add to it some information.\r\nMore specifically, he must add to the AMAZON-S3 pair his own cannonicalID, and to the GOOGLE-STORAGE pair his email.\r\n\r\nOnce the grantee user have this list with he, he can use it in the other operations (_read_, _write_, _delete_) to operate on the shared bucket.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}